{-# OPTIONS_GHC -Wall #-}
{-# LANGUAGE TemplateHaskell, LambdaCase, BlockArguments, GADTs, AllowAmbiguousTypes, FlexibleInstances
           , FlexibleContexts, TypeOperators, DataKinds, PolyKinds, ScopedTypeVariables #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE DeriveFunctor #-}

import Polysemy

import Polysemy.Writer

import Data.List
import System.Random
import Control.Monad.Random

import Data.Singletons.TH
import Data.Data
import qualified GHC.Generics

type Seed = Int

newtype Fix f = In (f (Fix f))

ana :: Functor f => (b -> f b) -> b -> Fix f
ana coalg b = In $ fmap (ana coalg) (coalg b)

data GenF a b = NextF a b | NilF
    deriving Functor

instance {-# OVERLAPPABLE #-} (Show a) => (Show (Fix (GenF a))) where
    show (In ff) = case ff of
        NextF a ff' -> show a ++ ", " ++ show ff'
        NilF -> "[]"

fixGenFAsList :: Fix (GenF a) -> [a]
fixGenFAsList (In ff) = case ff of
    NextF a ff' -> a : fixGenFAsList ff'
    NilF -> []

-- FIRST ATTEMPT, generates single blocks randomly, but input/output types must be same -- 
-- coalgebra:
-- takes in the set of possible actions, a random list, chooses an action on the list, filter the functions list
-- outputs selection and new actions lists + seed

data Arith m a where
    Plus :: (Num a, Show a) => a -> a -> Arith m a
    Sub  :: (Num a, Show a) => a -> a -> Arith m a
makeSem ''Arith

-- can be generated by templatehaskell
arithPossibles :: (Num a, Show a, Member Arith r) => [(a, a) -> Sem r a]
arithPossibles = [uncurry plus, uncurry sub]

runArith :: (Num a, Show a) => Sem (Arith : r) a -> Sem r a
runArith = interpret $ \case
    Plus a b -> return $ a + b
    Sub a b  -> return $ a - b

printName :: (Show a, Member (Writer String) r, Num a) => String -> String -> a -> a -> Sem r a
printName s c a b = do
    tell $ s ++ " " ++ show a ++ " " ++ c ++ " " ++ show b ++ "\n"
    return $ a + b

runAndPrintArith :: Members '[Writer String] r => Sem (Arith : r) a -> Sem r a
runAndPrintArith = interpret $ \case
    Plus a b -> printName "plus" "*" a b
    Sub a b -> printName "sub" "-" a b

-- the input to genCoAlg can include also: State 
data GenContext r a b = forall g. RandomGen g => Context {
    randGen  :: g,
    currProg :: Sem r b,
    -- generationState :: ST s a (stores e.g. scoping info)
    choices  :: [a -> Sem r b]
}

genBlockCoalg :: (Random a) => GenContext r a b -> GenF (Sem r b) (GenContext r a b)
genBlockCoalg (Context r p c) =
    let (i, r') = random r
        ci = i `mod` length c
        chosen = c !! ci
        (arg, r'') = random r'
        (reduce :: Int, r''') = randomR (0, 100) r''
    in if null c
        then NilF
        else NextF (chosen arg) (
            Context
                r'''
                (p >> chosen arg)
                (if reduce < 10
                    then let (h, _ : tt) = splitAt ci c in (h ++ tt)
                    else c)
            )

genBlock :: (Random a) => GenContext r a b -> Fix (GenF (Sem r b))
genBlock = ana genBlockCoalg

main :: IO ()
main = do
    putStrLn "guten tag."
    gen <- initStdGen
    let
        res :: (Fix (GenF (Sem '[Arith, Writer String] Int))) = genBlock (Context gen (return 1) arithPossibles)
        stmts = fixGenFAsList res
        block :: (Sem '[Arith, Writer String] Int) = foldr (>>) (return 0) stmts
        (o, _) = run $ runWriter $ runAndPrintArith block
    putStrLn $ "result is: \n" ++ o